<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
</head>
<body>
<svg style="width: 100%;max-height: 600px; background:#000822" width="5000px" height="5000px" viewBox="2000 2000 500 500" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <style>
    #s {transform-origin: 20px 20px;}#r {opacity: 0;transition: all 400ms ease-in-out;}.e,#b {transition: opacity 2000ms ease-in-out;}
  </style>
  <defs>
    <filter id="f" x="0" y="0">
      <feGaussianBlur in="SourceGraphic" stdDeviation="40" />
    </filter>
  </defs>
    <rect fill="#000822" x="0" y="0" width="5000" height="5000"></rect>
    <g id="b" style="opacity: 1"></g>
      <polygon style="transform:translate(1825px, 2005px)" id="m" fill="#484850" points="0 5.4 5.5 5.4 11 0 11 18 5.5 12.6 0 12.6"></polygon>
      <g id="s">
          <g stroke="#979797">
            <circle fill="#D8D8D8" cx="26.5" cy="6.5" r="6"></circle>
            <line x1="26.5" y1="13.5" x2="26.5" y2="26.5"></line>
            <line x1="26.5" y1="0.5" x2="0.5" y2="35.5"></line>
            <line x1="26.5" y1="0.5" x2="52.5" y2="35.5"></line>
          </g>
          <circle style="transform:translate(-100px, -100px)" id="r" fill="#C9EDFF" cx="125.5" cy="125.5" r="125.5"></circle>
      </g>
      <text style="transform:translate(2225px, 2225px)" x="-350" y="250" fill="#fff" font-family="Arial, sans-serif" id="t">Earth became dark. Scan for life, keep us alive in the minds of others. (Arrow keys to move/scan objects)</text>
</svg>

<script>
(function( global ) {

/*
 * Private stuffz
 */

var enharmonics = 'B#-C|C#-Db|D|D#-Eb|E-Fb|E#-F|F#-Gb|G|G#-Ab|A|A#-Bb|B-Cb',
  middleC = 440 * Math.pow( Math.pow( 2, 1 / 12 ), -9 ),
  numeric = /^[0-9.]+$/,
  octaveOffset = 4,
  space = /\s+/,
  num = /(\d+)/,
  offsets = {};

// populate the offset lookup (note distance from C, in semitones)
enharmonics.split('|').forEach(function( val, i ) {
  val.split('-').forEach(function( note ) {
    offsets[ note ] = i;
  });
});

/*
 * Note class
 *
 * new Note ('A4 q') === 440Hz, quarter note
 * new Note ('- e') === 0Hz (basically a rest), eigth note
 * new Note ('A4 es') === 440Hz, dotted eighth note (eighth + sixteenth)
 * new Note ('A4 0.0125') === 440Hz, 32nd note (or any arbitrary
 * divisor/multiple of 1 beat)
 *
 */

// create a new Note instance from a string
function Note( str ) {
  var couple = str.split( space );
  // frequency, in Hz
  this.frequency = Note.getFrequency( couple[ 0 ] ) || 0;
  // duration, as a ratio of 1 beat (quarter note = 1, half note = 0.5, etc.)
  this.duration = Note.getDuration( couple[ 1 ] ) || 0;
}

// convert a note name (e.g. 'A4') to a frequency (e.g. 440.00)
Note.getFrequency = function( name ) {
  var couple = name.split( num ),
    distance = offsets[ couple[ 0 ] ],
    octaveDiff = ( couple[ 1 ] || octaveOffset ) - octaveOffset,
    freq = middleC * Math.pow( Math.pow( 2, 1 / 12 ), distance );
  return freq * Math.pow( 2, octaveDiff );
};

// convert a duration string (e.g. 'q') to a number (e.g. 1)
// also accepts numeric strings (e.g '0.125')
// and compund durations (e.g. 'es' for dotted-eight or eighth plus sixteenth)
Note.getDuration = function( symbol ) {
  return numeric.test( symbol ) ? parseFloat( symbol ) :
    symbol.toLowerCase().split('').reduce(function( prev, curr ) {
      return prev + ( curr === 'w' ? 4 : curr === 'h' ? 2 :
        curr === 'q' ? 1 : curr === 'e' ? 0.5 :
        curr === 's' ? 0.25 : 0 );
    }, 0 );
};

typeof module !== 'undefined' && ( module.exports = Note );

/*
 * Sequence class
 */

// create a new Sequence
function Sequence( ac, tempo, arr ) {
  if ( ac ) {
    this.ac = ac;
    this.createFxNodes();
    this.tempo = tempo || 120;
    this.loop = true;
    this.smoothing = 0;
    this.staccato = 0;
    this.notes = [];
    this.push.apply( this, arr || [] );
  }
}

// create gain and EQ nodes, then connect 'em
Sequence.prototype.createFxNodes = function() {
  var eq = [ [ 'bass', 100 ], [ 'mid', 1000 ], [ 'treble', 2500 ] ],
    prev = this.gain = this.ac.createGain();
  this.wet = this.ac.createGain();
  this.dry = this.ac.createGain();
  eq.forEach(function( config, filter ) {
    filter = this[ config[ 0 ] ] = this.ac.createBiquadFilter();
    filter.type = 'peaking';
    filter.frequency.value = config[ 1 ];
    prev.connect( prev = filter );
  }.bind( this ));
  prev.connect( this.wet );
  prev.connect( this.dry );
  return this;
};

// accepts Note instances or strings (e.g. 'A4 e')
Sequence.prototype.push = function() {
  Array.prototype.forEach.call( arguments, function( note ) {
    this.notes.push( note instanceof Note ? note : new Note( note ) );
  }.bind( this ));
  return this;
};

// recreate the oscillator node (happens on every play)
Sequence.prototype.createOscillator = function() {
  this.stop();
  this.osc = this.ac.createOscillator();
  this.osc.type = this.waveType || 'square';
  this.osc.connect( this.gain );
  return this;
};

// schedules this.notes[ index ] to play at the given time
// returns an AudioContext timestamp of when the note will *end*
Sequence.prototype.scheduleNote = function( index, when ) {
  var duration = 60 / this.tempo * this.notes[ index ].duration,
    cutoff = duration * ( 1 - ( this.staccato || 0.00000000001 ) );

  this.setFrequency( this.notes[ index ].frequency, when );

  if ( this.smoothing && this.notes[ index ].frequency ) {
    this.slide( index, when, cutoff );
  }

  this.setFrequency( 0, when + cutoff );
  return when + duration;
};

// get the next note
Sequence.prototype.getNextNote = function( index ) {
  return this.notes[ index < this.notes.length - 1 ? index + 1 : 0 ];
};

// how long do we wait before beginning the slide? (in seconds)
Sequence.prototype.getSlideStartDelay = function( duration ) {
  return duration - Math.min( duration, 60 / this.tempo * this.smoothing );
};

// slide the note at <index> into the next note at the given time,
// and apply staccato effect if needed
Sequence.prototype.slide = function( index, when, cutoff ) {
  var next = this.getNextNote( index ),
    start = this.getSlideStartDelay( cutoff );
  this.setFrequency( this.notes[ index ].frequency, when + start );
  this.rampFrequency( next.frequency, when + cutoff );
  return this;
};

// set frequency at time
Sequence.prototype.setFrequency = function( freq, when ) {
  this.osc.frequency.setValueAtTime( freq, when );
  return this;
};

// ramp to frequency at time
Sequence.prototype.rampFrequency = function( freq, when ) {
  this.osc.frequency.linearRampToValueAtTime( freq, when );
  return this;
};

// run through all notes in the sequence and schedule them
Sequence.prototype.play = function( when ) {
  when = typeof when === 'number' ? when : this.ac.currentTime;

  this.createOscillator();
  this.osc.start( when );

  this.notes.forEach(function( note, i ) {
    when = this.scheduleNote( i, when );
  }.bind( this ));

  this.osc.stop( when );
  this.osc.onended = this.loop ? this.play.bind( this, when ) : null;

  return this;
};

// stop playback, null out the oscillator, cancel parameter automation
Sequence.prototype.stop = function() {
  if ( this.osc ) {
    this.osc.onended = null;
    this.osc.stop( 0 );
    this.osc.frequency.cancelScheduledValues( 0 );
    this.osc = null;
  }
  return this;
};

typeof module !== 'undefined' && ( module.exports = Sequence );

global.Note = Note;
global.Sequence = Sequence;

}( typeof window !== 'undefined' ? window : this ) );



var ac, tempo = 24, volume = 0.08;

if ( window.AudioContext || window.webkitAudioContext ) {
ac = new ( window.AudioContext || window.webkitAudioContext )();
}

let main;
let base;
generateNotes()
let bass = new Sequence( ac, tempo, base);
let lead = new Sequence( ac, tempo, main);
initMusic();


let svg = document.querySelector("svg");
let ship = svg.querySelector("#s");
let radar = svg.querySelector("#r");
let objects = svg.querySelector("#b");
let soundButton = svg.querySelector("#m");
let text = svg.querySelector("text");
let degrees = 0;
let velocityX = 0;
let velocityY = 0;
let positionX = 2225;
let positionY = 2225;
let map = [];
let sector = [500, 500];
let ftl;
let gravityDrive;
let longRangeScanners;

let general = [
  {
    t: "None. Planet $. No intelligent life.",
    s: rand(200, 500),
    h: getColor('f'),
    n: "n"
  },
  {
    p: "168.445312 70.609375 0.140625 190.21875 64.5546875 249.554687 217.242187 287.96875 267.320312 202.179687 379.273437 144.320312 247.25 0.3984375 136.1875 23.15625",
    t: "None. Asteroid $. No intelligent life.",
    s: rand(20, 200),
    h: getColor('808080'),
    n: "n",
    m: "a",
  },
  {
    p: "31.765625 185.992188 0.6015625 217.789062 0.6015625 245.039062 31.765625 270.3125 62.859375 270.3125 94.671875 228.152344 225.0625 -0.0703125",
    t: "None. Comet $. No intelligent life.",
    s: rand(50, 100),
    h: getColor('897eff'),
    n: "n"
  },
  {
    t: "None. Gas Giant $. No intelligent life.",
    s: rand(400, 700),
    h: getColor('f'),
    n: "n"
  },
  {
    t: "None. Star $. No intelligent life.",
    s: rand(800, 1000),
    c: [2000, 2000],
    h: getColor('fffd'),
    n: "n"
  },
]

let specials = [
  {
    p: "55.203125 163.25 -0.1015625 119.460938 460.898438 130.214844 212.976563 191.398438 166.601563 33.2109375 430.695313 259.9375 361.695313 290.039062 337.304688 0.4921875",
    t: "Alien. Artifacts. Ancient. Debris. Alone. Incoperate tech. (Up arrow 4x)",
    s: rand(20, 100),
    h: getColor('00a7'),
    u: "s"
  },
  {
    P: "0.46875 72.4140625 383.25 0.28125 307.546875 172.695312",
    t: "Planet. Ancient. Civilization. Debris. Alone. Incoperate tech. ('S' key to toggle)",
    s: rand(200, 500),
    h: getColor('00bd'),
    u: "r"
  },
  {
    p: "241.34375 59.71875 -0.1015625 119.460938 212.976562 136.921875 212.976562 191.398437 271.257812 159.421875 430.695312 259.9375 347.992188 75.640625 337.304688 0.4921875",
    t: "Ship. Ancient. Debris. Alone. Incoperate tech. ('W' key to FTL)",
    s: rand(20, 100),
    h: getColor('00a7'),
    u: "w"
  },
  {
    p:"32.2890625 80.0625 177.3125 0.171875 302.828125 57.3125 351.289062 40.1171875 327.984375 122.078125 302.828125 80.0625 160.085938 111.429688 47.9921875 122.078125 -0.0546875 98.8984375", // ellipse
    t: "Whale. Moos. Friend.",
    s: rand(20, 100),
    h: getColor('00bd')
  },
  {
    t: "Probe. Sister. Debris. Alone.",
    s: 12,
    h: getColor('D8D8D8')
  },
  {
    t: "We are ancient. We are friend. Journey on. Incoperate tech. ('W', 'S' keys)",
    s: rand(200, 500),
    h: getColor('000000'),
    u: "a"
  },
  {
    t: "",
    s: rand(200, 500),
    h: getColor('56ccff'),
    w:'t'
  }
]

let setDirection = {
  '0':[0, -2],
  '30':[1, -2],
  '60':[2, -1],
  '90':[2, 0],
  '120':[2, 1],
  '150':[1, 1],
  '180':[0, 2],
  '210':[-1, 2],
  '240':[-1, 1],
  '270':[-2, 0],
  '300':[-1, -1],
  '330':[-1, -2],
}

let o = null
let g = null
let tickCount = 0;
let interval;
let soundEnabled = false;

init();
function init () {
  soundButton.addEventListener('click', ()=>{soundEnabled = !soundEnabled; soundEnabled ? play() : stop() }, false);
  document.addEventListener('keydown', keyHandling, false);
  genMaps();
  move;
  layoutStars();
  layoutBodies();
  interval = setInterval(tick, 10);
}

function tick () {
  move();
  tickCount++;
}

function keyHandling (e) {
  let callback = {
      'ArrowLeft':()=>{degrees -= 30},
      'ArrowRight':()=>{degrees += 30},
      'ArrowUp':()=>{
        let str = degrees+"";
        if (gravityDrive &&
        Math.abs(velocityX) < 9 &&
        Math.abs(velocityY) < 9) {
          velocityX += setDirection[str][0];
          velocityY += setDirection[str][1];
        } else {
          velocityX = setDirection[str][0];
          velocityY = setDirection[str][1];
        }
      },
      'ArrowDown':scan,
      's':()=>{longRangeScanners ? longRangeScanners === 't' ? longRangeScanners = 'f' : longRangeScanners = 't' : null},
      'w':()=>{
        if (!ftl) return;
        sector[0] = rand(0, 1000);
        sector[1] = rand(0, 1000);
        positionX = rand(10, 4500);
        positionY = rand(10, 4500);
        layoutBodies();
        text.textContent = '';
      },
      'p':()=>{
        ftl = true;
        longRangeScanners = "f";
        gravityDrive = true;
      }
  }[e.key];
  callback && callback();
}

function move () {
  if (degrees === 360) degrees = 0;
  if (degrees < 0) degrees = 360 + degrees;

  if (positionX + velocityX > 5000) {
    sector[1] += 1;
    layoutBodies();
    text.textContent = '';
    positionX = 0;
  }
  if (positionX + velocityX < 0) {
    sector[1] -= 1;
    layoutBodies();
    text.textContent = '';
    positionX = 5000;
  }

  if (positionY + velocityY > 5000) {
    sector[0] += 1;
    layoutBodies();
    text.textContent = '';
    positionY = 0;
  }
  if (positionY + velocityY < 0) {
    sector[0] -= 1;
    layoutBodies();
    text.textContent = '';
    positionY = 5000;
  }

  positionX += velocityX;
  positionY += velocityY;
  ship.style.transform = 'translate('+positionX+'px, '+positionY+'px) rotate('+degrees+'deg)';
  soundButton.style.transform = 'translate('+(positionX - 400)+'px, '+(positionY - 220)+'px)';
  if (longRangeScanners && longRangeScanners === "t") {
    svg.setAttribute('viewBox', '0 0 5000 5000');
  } else {
    svg.setAttribute('viewBox', (positionX-225)+' '+(positionY-225)+' 500 500');
  }
}

function layoutStars () {
  for (let i = 0; i < 1000; i++) {
    let circle = addElement(2);
    circle.style.transform = 'translate('+getRandom()*5000+'px, '+getRandom()*5000+'px)'
  }
}

function layoutBodies () {
  let bodies = objects.querySelectorAll(".c");
  for (let k = 0; k < bodies.length; k++) {
    if (bodies[k]) bodies[k].remove();
  }

  if (!map[sector[0]] || !map[sector[0]][sector[1]]) {
    win();
    return;
  }
  let sec = map[sector[0]][sector[1]];
  if (sec.length > 0) {
    for (let j = 0; j < sec.length; j++) {
      let node = addElement(Math.floor(sec[j].s), sec[j].h, sec[j].p || undefined);
      node.classList.add("c");
      if (!sec[j].c) {
        sec[j].c = [];
        sec[j].c[0] = rand(0, 5000);
        sec[j].c[1] = rand(0, 5000);
      }
      if (sec[j].n) sec[j].n = (sector[1] +""+ sec[j].c[1] +""+ sector[0]) + sec[j].h.replace("#", "-");
      node.style.transform = 'translate('+sec[j].c[1]+'px, '+sec[j].c[0]+'px)'
      if (sec[j].m) {
        multipleObjects(node, sec[j]);
        return;
      }
    }
  }
}

function multipleObjects (node, obj) {
  let num = rand(1, 10);
  if (num > 10) num = 10;
  for (let i = 0; i < num; i++) {
    let value = getRandom() * 0xFF | 0;
    let grayscale = (value << 16) | (value << 8) | value;
    let color = '#' + grayscale.toString(16);
    let tmpNode = node.cloneNode(true);
    tmpNode.style.transform = 'translate('+(obj.c[1] +(getRandom()*500))+'px, '+(obj.c[0]+(getRandom()*600))+'px) scale('+getRandom()+') rotate('+(getRandom()*360)+'deg)';
    tmpNode.style.fill = '#' + grayscale.toString(16);
    objects.appendChild(tmpNode);
  }
}

function scan () {
  radar.style.opacity = 0.8;
  setTimeout(()=>{radar.style.opacity = 0;}, 400)
  velocityX = 0;
  velocityY = 0;
  let sec = map[sector[0]][sector[1]];
  text.textContent = "Tir: Hello?";
  text.style.transform = 'translate('+positionX+'px, '+positionY+'px)';
  for (let i = 0; i < sec.length; i++) {
    if (Math.abs(positionX - (sec[i].c[1]+sec[i].s)) < 300 &&
    Math.abs(positionY - (sec[i].c[0]+sec[i].s)) < 300) {
      playTone = true;
      if (sec[i].w) {
        win('w');
        break;
      }
      if (sec[i].u) {
        if (sec[i].u === "w") ftl = true;
        if (sec[i].u === "r") longRangeScanners = "f";
        if (sec[i].u === "s") gravityDrive = true;
        if (sec[i].u === "a") {
          ftl = true;
          longRangeScanners = "f";
          gravityDrive = true;
        }
      }
      let responseText = sec[i].t;
      if (sec[i].n) responseText = responseText.replace('$', sec[i].n)
      text.textContent = "Tir: Hello? Response: "+ responseText;
      break;
    }
  }
}

function addElement (size, color, points) {
  let newElement = document.createElementNS("http://www.w3.org/2000/svg", points ? "polygon" : "circle");
  if (points) {
    newElement.setAttribute("points",points);
  } else {
    newElement.setAttribute("cx",size);
    newElement.setAttribute("cy",size);
    newElement.setAttribute("r",size/2);
  }
  newElement.setAttribute("fill",color || '#fff');
  objects.appendChild(newElement);
  return newElement;
}

function genMaps () {
  for (let i = 0; i < 1000; i++) {
    map.push([]);
    for (let j = 0; j < 1000; j++) {
      let tmp = [];
      if (i === 500 && j === 500) {
        let startPlanet = {...general[0]};
        startPlanet.s = 200;
        startPlanet.c = [2100, 2225];
        startPlanet.h = "#18cef1";
        startPlanet.w = "t";
        tmp.push(startPlanet);
      } else {
        if (getRandom() > 0.5) tmp.push(generateSpaceObject());
        if (getRandom() > 0.5) tmp.push(generateSpaceObject());
        if (getRandom() > 0.5) tmp.push(generateSpaceObject());
        if (getRandom() > 0.95) tmp.push(generateSpecial());
      }

      map[i].push(tmp);
    }
  }
}

function getRandom () {
  return Math.random();
}

function generateSpaceObject () {
  return {...general[Math.floor(getRandom() * general.length)]};
}

function generateSpecial () {
  return {...specials[Math.floor(getRandom() * specials.length)]};
}

function getColor (i) {
  let color = (getRandom()*100000000).toString(16);
  return '#'+i+color.substring(0, 6 - i.length)
}

function rand (min, multiplier) {
  let num = Math.floor(getRandom()* multiplier);
  return num < min ? min : num;
}

function win (type) {
  clearInterval(interval);
  svg.setAttribute('viewBox', (positionX-225)+' '+(positionY-225)+' 500 500');
  text.textContent = "";
  objects.style.opacity = 0;
  text.style.opacity = 0;
  text.classList.add('e');
  let lowerText = text.cloneNode(true);
  let lowestText = text.cloneNode(true);
  svg.appendChild(lowerText);
  svg.appendChild(lowestText);
  setTimeout(end, 4000);

  function end () {
    setTimeout(() => {
        stop();
      }, 16000);
    let texts = svg.querySelectorAll(".e");
    let endText = [
      "You are probe. Welcome home. We sent you out when all hope had escaped us. ",
      "You were to tell others of our story, so not all was lost. You have done well. ",
      "Speak your journey. Come, rest our friend. Together."
    ];
    let endText2 = [
      "We have watched you for millennia. You are a testiment to your creators. ",
      "Few have built anything that traveled beyond this galaxies wall. Come rest. ",
      "You have done well. We will honor you and your journey. Together."
    ]
    for (let i = 0; i < texts.length; i++) {
      texts[i].style.transform = 'translate('+positionX+'px, '+(positionY - ((3 - i)*50))+'px)';
      texts[i].textContent = type === 'w' ? endText[i] : endText2[i];
      texts[i].style.opacity = 0;
      setTimeout(() => {
        texts[i].style.opacity = 1;
      }, i*3000);
    }
  }
}



function generateNotes () {
let notesArr = ['_  e','E4 q','F#4 e','D4 q','B3 e','G4 q','E4 e','B4 h','A4 q','A4 e','A4 q','G4  e','F#4 e','E4 e'];
let baseNotesArr = ['D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','D e','G4 e','G4 e','G4 e','G4 e','B4 e','B4 e','B4 e','G5 e','B4 e','G5 e','B4 e','G4 e','G4 e','D e','C4 e','C5 q','D5 q','C4 3'];
let tmpNotesArr = ['_  e','_  e','_  e','_  e'];
let tmpBaseNotesArr = [...baseNotesArr, ...baseNotesArr,...baseNotesArr];
for (let index = 0; index < 1000; index++) {
  tmpNotesArr.push(notesArr[Math.floor(getRandom() * notesArr.length)]);
  tmpBaseNotesArr.push(baseNotesArr[Math.floor(getRandom() * baseNotesArr.length)]);
}
main = tmpNotesArr;
base = tmpBaseNotesArr
}

function initMusic () {
if ( ac ) {
  let osc = ac.createOscillator();
  let compressor = ac.createDynamicsCompressor();
  let output = ac.createGain();
  output.connect( ac.destination );
  output.gain.value = volume;
  let reverb = ac.createConvolver();
  reverb.buffer = createReverb( 2 );
  reverb.connect( compressor );
  osc.frequency.value = 0;
  osc.connect( compressor );
  osc.start();
  lead.wet.connect( reverb );
  bass.dry.connect( compressor );
  lead.dry.connect( compressor );

  compressor.connect( output );
  bass.waveType = 'sine';
  bass.treble.type = 'lowpass';
  lead.waveType = 'sine';
}
}

function play () {
let now;
if ( ac ) {
  now = ac.currentTime;
  lead.play( now );
  bass.play( now );
}
}

function stop () {
if ( ac ) {
  lead.stop();
  bass.stop();
}
}

function createReverb ( ) {
var sr = ac.sampleRate,
  len = sr * 2,
  impulse = ac.createBuffer( 2, len, sr ),
  impulseL = impulse.getChannelData( 0 ),
  impulseR = impulse.getChannelData( 1 ),
  i = 0;
for ( ; i < len; ++i ) {
  impulseL[ i ] = ( getRandom() * 2 - 1 ) * Math.pow( 1 - i / len, 2.0 );
  impulseR[ i ] = ( getRandom() * 2 - 1 ) * Math.pow( 1 - i / len, 2.0 );
}
return impulse;
}

</script>
</body>
</html>